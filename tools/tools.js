const path = require("path")
const fs = require("fs")
const util = require("util")
const si = require('systeminformation')

function readConfig() {
  return new Promise(resolve => {
    var MMConfig = undefined
    let file = path.resolve(__dirname, "../../../config/config.js")
    if (fs.existsSync(file)) MMConfig = require(file)
    resolve(MMConfig)
  })
}

/** search installed EXT from DB**/
function searchConfigured (config,ext) {
  try {
    var Configured = []
    config.modules.find(m => {
      if (ext.includes(m.module)) Configured.push(m.module)
    })
    return Configured.sort()
  } catch (e) {
    console.log("[GATEWAY] Error! " + e)
    return Configured.sort()
  }
}

/** search installed EXT **/
function searchInstalled (ext) {
  var Installed = []
  ext.find(m => {
    if (fs.existsSync(path.resolve(__dirname + "/../../" + m + "/package.json"))) {
      let name = require((path.resolve(__dirname + "/../../" + m + "/package.json"))).name
      if (name == m) Installed.push(m)
      else console.warn("[GATEWAY] Found:", m, "but in package.json name is not the same:", name)
    }
  })
  return Installed.sort()
}

function timeStamp() {
  var now = new Date()
  var date = [ now.getFullYear(), now.getMonth() + 1, now.getDate() ]
  var time = [ now.getHours(), now.getMinutes(), now.getSeconds() ]
  for (var i = 0; i < 3; i++ ) {
    if (time[i] < 10) {
      time[i] = "0" + time[i]
    }
    if (date[i] < 10) {
      date[i] = "0" + date[i]
    }
  }
  return date.join("") + "-" +time.join(":")
}

function saveConfig(MMConfig) {
  return new Promise(resolve => {
    var configPath = path.resolve(__dirname, "../../../config/config.js")
    let backupPath = path.resolve(__dirname, "../backup/config.js.GW." + timeStamp())
    var source = fs.createReadStream(configPath)
    var destination = fs.createWriteStream(backupPath)

    source.pipe(destination, { end: false })
    source.on("end", () => {
      var header = "/*** GENERATED BY @bugsounet Gateway v" + require("../package.json").version + " ***/\n/*** https://forum.bugsounet.fr **/\n\nvar config = "
      var footer = "\n\n/*************** DO NOT EDIT THE LINE BELOW ***************/\nif (typeof module !== 'undefined') {module.exports = config;}\n"

      fs.writeFile(configPath, header + util.inspect(MMConfig, {
          showHidden: false,
          depth: null,
          maxArrayLength: null,
          compact: false
        }) + footer,
        (error) => {
          if (error) {
            resolve({error: "Error when writing file" })
            return console.error("[GATEWAY] error", error)
          }
          console.log("[GATEWAY] Gateway saved new configuration!")
          console.log("[GATEWAY] Backup saved in", backupPath)
          resolve({done: "ok" })
        }
      )
    })
    destination.on("error", (error) => {
      resolve({error: "Error when writing file" })
      console.log("[GATEWAY]", error)
    })
  })
}

function configAddOrModify(EXTConfig, MMConfig) {
  return new Promise(resolve => {
    modules = MMConfig.modules
    index = modules.map(e => { return e.module }).indexOf(EXTConfig.module)
    if (index > -1) modules[index] = EXTConfig
    else modules.push(EXTConfig)
    resolve(MMConfig)
  })
}

function configDelete(EXT, MMConfig) {
  return new Promise(resolve => {
    modules = MMConfig.modules
    index = modules.map(e => { return e.module }).indexOf(EXT)
    modules.splice(index, 1) // delete modules
    resolve(MMConfig)
  })
}

function loadBackupNames() {
  return new Promise(resolve => {
    const regex = "config.js.GW"
    var List = []
    var FileList = fs.readdirSync(path.resolve(__dirname, "../backup/"))
    FileList.forEach((file) => {
      const testFile = file.match(regex)
      if (testFile) List.push(file)
    })
    List.sort()
    List.reverse()
    resolve(List)
  })
}

function loadBackupFile(file) {
  return new Promise(resolve => {
    var BackupConfig = {}
    let filePath = path.resolve(__dirname, "../backup/" + file)
    if (fs.existsSync(filePath)) BackupConfig = require(filePath)
    resolve(BackupConfig)
  })
}

function getIP () {
  return new Promise((resolve) => {
    si.networkInterfaceDefault()
      .then(defaultInt=> {
        si.networkInterfaces().then(data => {
          var Interfaces= []
          var int =0
          data.forEach(interface => {
            var info = {}
            if (interface.type == "wireless") {
              info = {
                ip: interface.ip4 ? interface.ip4 : "unknow",
                default: (interface.iface == defaultInt) ? true: false
              }
            }
            if (interface.type == "wired") {
              info = {
                ip: interface.ip4 ? interface.ip4 : "unknow",
                default: (interface.iface == defaultInt) ? true: false
              }
            }
            if (interface.iface != "lo") Interfaces.push(info)
            if (int == data.length-1) resolve(Interfaces)
            else int +=1
          })
        })
      })
      .catch(error => {
        console.log(error)
        var info = {}
        info = {
          ip: "127.0.0.1",
          default: true
        }
        Interfaces.push(info)
        resolve(Interfaces)
      })
  })
}

/** search and purpose and ip address **/
async function purposeIP() {
  var IP = await getIP()
  var found = 0
  return new Promise(resolve => {
    IP.forEach(network => {
      if (network.default) {
        resolve(network.ip)
        found = 1
        return
      }
    })
    if (!found) resolve("127.0.0.1")
  })
}

/** config merge **/
function configMerge(result) {
  var stack = Array.prototype.slice.call(arguments, 1)
  var item
  var key
  while (stack.length) {
    item = stack.shift()
    for (key in item) {
      if (item.hasOwnProperty(key)) {
        if (typeof result[key] === "object" && result[key] && Object.prototype.toString.call(result[key]) !== "[object Array]") {
          if (typeof item[key] === "object" && item[key] !== null) {
            result[key] = configMerge({}, result[key], item[key])
          } else {
            result[key] = item[key]
          }
        } else {
          result[key] = item[key]
        }
      }
    }
  }
  return result
}

function checkElectronOptions(config) {
  if (typeof config.electronOptions === "object" &&
    typeof config.electronOptions.webPreferences === "object" &&
    config.electronOptions.webPreferences.webviewTag
  ) return true
  else return false
}

exports.purposeIP = purposeIP
exports.readConfig = readConfig
exports.saveConfig = saveConfig
exports.configAddOrModify = configAddOrModify
exports.configDelete = configDelete
exports.searchConfigured = searchConfigured
exports.searchInstalled = searchInstalled
exports.loadBackupNames = loadBackupNames
exports.loadBackupFile = loadBackupFile
exports.configMerge = configMerge
exports.checkElectronOptions = checkElectronOptions
