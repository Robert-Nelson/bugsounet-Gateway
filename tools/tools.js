const path = require("path")
const fs = require("fs")
const util = require("util")
const si = require('systeminformation')
const pm2 = require('pm2')
var spawn = require('child_process').spawn
const { createUpnpClient } = require('@bugsounet/nat-api')

function readConfig() {
  return new Promise(resolve => {
    var MMConfig = undefined
    let file = path.resolve(__dirname, "../../../config/config.js")
    if (fs.existsSync(file)) MMConfig = require(file)
    resolve(MMConfig)
  })
}

/** read streamsConfig.json of EXT-FreeboxTV**/
function readFreeteuseTV() {
  return new Promise(resolve => {
    var streamsConfig = undefined
    let file = path.resolve(__dirname, "../../EXT-FreeboxTV/streamsConfig.json")
    if (fs.existsSync(file)) streamsConfig = require(file)
    resolve(streamsConfig)
  })
}

function readRadioRecipe(lang) {
  return new Promise(resolve => {
    var RadioResult = undefined
    let file = path.resolve(__dirname, "../../EXT-RadioPlayer/recipe/EXT-RadioPlayer."+lang+".js")
    try {
      if (fs.existsSync(file)) RadioResult = require(file).recipe.commands
    } catch (e) {
      resolve(RadioResult)
      console.error("[GATEWAY][Radio] error when loading file", file)
    }
    resolve(RadioResult)
  })
}

/** search installed EXT from DB**/
function searchConfigured (config,ext) {
  try {
    var Configured = []
    config.modules.find(m => {
      if (ext.includes(m.module)) Configured.push(m.module)
    })
    return Configured.sort()
  } catch (e) {
    console.log("[GATEWAY] Error! " + e)
    return Configured.sort()
  }
}

/** search installed EXT **/
function searchInstalled (ext) {
  var Installed = []
  ext.find(m => {
    if (fs.existsSync(path.resolve(__dirname + "/../../" + m + "/package.json"))) {
      let name = require((path.resolve(__dirname + "/../../" + m + "/package.json"))).name
      if (name == m) Installed.push(m)
      else console.warn("[GATEWAY] Found:", m, "but in package.json name is not the same:", name)
    }
  })
  return Installed.sort()
}

/** search if GA installed **/
function searchGA () {
  var version = 0
  if (fs.existsSync(path.resolve(__dirname + "/../../MMM-GoogleAssistant/package.json"))) {
    let name = require((path.resolve(__dirname + "/../../MMM-GoogleAssistant/package.json"))).name
    if (name == "MMM-GoogleAssistant") {
      version = require((path.resolve(__dirname + "/../../MMM-GoogleAssistant/package.json"))).version
    }
    else console.warn("[GATEWAY] Found: MMM-GoogleAssistant but in package.json name is not the same:", name)
  }
  return version
}

/** timeStamp for backup **/
function timeStamp() {
  var now = new Date()
  var date = [ now.getFullYear(), now.getMonth() + 1, now.getDate() ]
  var time = [ now.getHours(), now.getMinutes(), now.getSeconds() ]
  for (var i = 0; i < 3; i++ ) {
    if (time[i] < 10) {
      time[i] = "0" + time[i]
    }
    if (date[i] < 10) {
      date[i] = "0" + date[i]
    }
  }
  return date.join("") + "-" +time.join(":")
}

/** Save MagicMirror config with backup **/
function saveConfig(MMConfig) {
  return new Promise(resolve => {
    var configPath = path.resolve(__dirname, "../../../config/config.js")
    let backupPath = path.resolve(__dirname, "../backup/config.js.GW." + timeStamp())
    var source = fs.createReadStream(configPath)
    var destination = fs.createWriteStream(backupPath)

    source.pipe(destination, { end: false })
    source.on("end", () => {
      var header = "/*** GENERATED BY @bugsounet Gateway v" + require("../package.json").version + " ***/\n/*** https://forum.bugsounet.fr **/\n\nvar config = "
      var footer = "\n\n/*************** DO NOT EDIT THE LINE BELOW ***************/\nif (typeof module !== 'undefined') {module.exports = config;}\n"

      fs.writeFile(configPath, header + util.inspect(MMConfig, {
          showHidden: false,
          depth: null,
          maxArrayLength: null,
          compact: false
        }) + footer,
        (error) => {
          if (error) {
            resolve({error: "Error when writing file" })
            return console.error("[GATEWAY] error", error)
          }
          console.log("[GATEWAY] Gateway saved new configuration!")
          console.log("[GATEWAY] Backup saved in", backupPath)
          resolve({done: "ok" })
        }
      )
    })
    destination.on("error", (error) => {
      resolve({error: "Error when writing file" })
      console.log("[GATEWAY]", error)
    })
  })
}

/** insert or modify plugins config to MagicMirror config **/
function configAddOrModify(EXTConfig, MMConfig) {
  return new Promise(resolve => {
    modules = MMConfig.modules
    index = modules.map(e => { return e.module }).indexOf(EXTConfig.module)
    if (index > -1) modules[index] = EXTConfig
    else modules.push(EXTConfig)
    resolve(MMConfig)
  })
}

/** delete plugins config **/
function configDelete(EXT, MMConfig) {
  return new Promise(resolve => {
    modules = MMConfig.modules
    index = modules.map(e => { return e.module }).indexOf(EXT)
    modules.splice(index, 1) // delete modules
    resolve(MMConfig)
  })
}

/** list of all backups **/
function loadBackupNames() {
  return new Promise(resolve => {
    const regex = "config.js.GW"
    var List = []
    var FileList = fs.readdirSync(path.resolve(__dirname, "../backup/"))
    FileList.forEach((file) => {
      const testFile = file.match(regex)
      if (testFile) List.push(file)
    })
    List.sort()
    List.reverse()
    resolve(List)
  })
}

/** delete all backups **/
function deleteBackup() {
  return new Promise(resolve => {
    const regex = "config.js.GW"
    var FileList = fs.readdirSync(path.resolve(__dirname, "../backup/"))
    FileList.forEach((file) => {
      const testFile = file.match(regex)
      if (testFile) {
        pathFile= path.resolve(__dirname, "../backup/"+file)
        try {
          fs.unlinkSync(pathFile)
          //console.log("[GATEWAY] Removed:", file)
        } catch (e) {
          console.error("[GATEWAY] Error occurred while trying to remove this file:", file)
        }
      }
    })
    resolve({done: "ok"})
  })
}

/** read and send bakcup **/
function loadBackupFile(file) {
  return new Promise(resolve => {
    var BackupConfig = {}
    let filePath = path.resolve(__dirname, "../backup/" + file)
    if (fs.existsSync(filePath)) BackupConfig = require(filePath)
    resolve(BackupConfig)
  })
}

/** get default ip address **/
function getIP () {
  return new Promise((resolve) => {
    si.networkInterfaceDefault()
      .then(defaultInt=> {
        si.networkInterfaces().then(data => {
          var Interfaces= []
          var int =0
          data.forEach(interface => {
            var info = {}
            if (interface.type == "wireless") {
              info = {
                ip: interface.ip4 ? interface.ip4 : "unknow",
                default: (interface.iface == defaultInt) ? true: false
              }
            }
            if (interface.type == "wired") {
              info = {
                ip: interface.ip4 ? interface.ip4 : "unknow",
                default: (interface.iface == defaultInt) ? true: false
              }
            }
            if (interface.iface != "lo") Interfaces.push(info)
            if (int == data.length-1) resolve(Interfaces)
            else int +=1
          })
        })
      })
      .catch(error => {
        console.log(error)
        var info = {}
        info = {
          ip: "127.0.0.1",
          default: true
        }
        Interfaces.push(info)
        resolve(Interfaces)
      })
  })
}

/** search and purpose and ip address **/
async function purposeIP() {
  var IP = await getIP()
  var found = 0
  return new Promise(resolve => {
    IP.forEach(network => {
      if (network.default) {
        resolve(network.ip)
        found = 1
        return
      }
    })
    if (!found) resolve("127.0.0.1")
  })
}

/** config merge **/
function configMerge(result) {
  var stack = Array.prototype.slice.call(arguments, 1)
  var item
  var key
  while (stack.length) {
    item = stack.shift()
    for (key in item) {
      if (item.hasOwnProperty(key)) {
        if (typeof result[key] === "object" && result[key] && Object.prototype.toString.call(result[key]) !== "[object Array]") {
          if (typeof item[key] === "object" && item[key] !== null) {
            result[key] = configMerge({}, result[key], item[key])
          } else {
            result[key] = item[key]
          }
        } else {
          result[key] = item[key]
        }
      }
    }
  }
  return result
}

/** check electron Options for find webviewTag **/
function checkElectronOptions(config) {
  if (typeof config.electronOptions === "object" &&
    typeof config.electronOptions.webPreferences === "object" &&
    config.electronOptions.webPreferences.webviewTag
  ) return true
  else return false
}

/** enable webview tag **/
function setWebviewTag(MMConfig) {
  return new Promise(resolve => {
    let options = {
      electronOptions: {
        webPreferences: {
          webviewTag: true
        }
      }
    }
    MMConfig = configMerge({}, MMConfig, options)
    resolve(MMConfig)
  })
}

/** Part of EXT-UpdateNotification **/
// MagicMirror restart and stop
function restartMM (config) {
  if (config.usePM2) {
    console.log("[GATEWAY] PM2 will restarting MagicMirror...")
    pm2.restart(config.PM2Id, (err, proc) => {
      if (err) {
        console.log("[GATEWAY] " + err)
      }
    })
  }
  else doRestart()
}

function doRestart () {
  console.log("[GATEWAY] Restarting MagicMirror...")
  var MMdir = path.normalize(__dirname + "/../../../")
  const out = process.stdout
  const err = process.stderr
  const subprocess = spawn("npm start", {cwd: MMdir, shell: true, detached: true , stdio: [ 'ignore', out, err ]})
  subprocess.unref()
  process.exit()
}

function doClose (config) {
  console.log("[GATEWAY] Closing MagicMirror...")
  if (config.usePM2) {
    pm2.stop(config.PM2Id, (err, proc) => {
      if (err) {
        console.log("[GATEWAY] " + err)
      }
    })
  }
  else process.exit()
}

/** read and search GA config **/
function getGAConfig (config) {
  var index = config.modules.map(e => { return e.module }).indexOf("MMM-GoogleAssistant")
  if (index > -1) return config.modules[index]
  else return {}
}

/** create schema Validation with template and translation **/
function makeSchemaTranslate(schema, translation) {
  /* replace {template} by translation */
  function translate(template) {
    return template.replace(new RegExp("{([^}]+)}", "g"), function (_unused, varName) {
      if (varName in translation === false) console.warn("[GATEWAY][Translator] Missing:", template)
      return varName in translation ? translation[varName] : "{" + varName + "}"
    })
  }

  /* read object in deep an search what translate */
  function makeTranslate(result) {
    var stack = Array.prototype.slice.call(arguments, 0)
    var item
    var key
    while (stack.length) {
      item = stack.shift()
      for (key in item) {
        if (item.hasOwnProperty(key)) {
          if (typeof result[key] === "object" && result[key] && Object.prototype.toString.call(result[key]) !== "[object Array]") {
            if (typeof item[key] === "object" && item[key] !== null) {
              result[key] = makeTranslate({}, result[key], item[key])
            } else {
              result[key] = item[key]
            }
          } else {
            if ((key == "title" || key == "description") && result[key]) {
              result[key] = translate(item[key])
            }
            else result[key] = item[key]
          }
        }
      }
    }
    return result
  }
  return makeTranslate(schema)
}

/** create logs file fom array **/
function readAllMMLogs(logs) {
  return new Promise(resolve => {
    var result = ""
    logs.forEach(log => {
      result += log.replace(/\r?\n/g, "\r\n")
    })
    resolve(result)
  })
}

async function portMapping(config,loginWarn) {
  var result = {
    ip: "0.0.0.0",
    done: false
  }
  return new Promise(async resolve => {
    try {
      const client = await createUpnpClient()
      const ip = await client.externalIp()
      result.ip = ip
      const currentMappings = await client.getMappings()
      if (currentMappings.length) {
        currentMappings.forEach(async mapping => {
          if(mapping.description == "@bugsounet Gateway v2") {
            console.log("[GATEWAY][UPNP] Found Gateway upnp config:")
            if (mapping.public) {
              if ((mapping.public.port == config.portMapping) && (mapping.private.port == config.port) && !config.noLogin && !loginWarn) {
                // already set
                console.log("[GATEWAY][UPNP] Already mapped: Internal", mapping.private.port, "-> External", mapping.public.port)
                result.done = true
                resolve(result)
              }
              else {
                //delete old config
                await client.unmap({ public: mapping.public.port })
                console.log("[GATEWAY][UPNP] Unmapping: Internal", mapping.private.port, "-> External", mapping.public.port)
              }
            }
          }
        })
      }
      if (result.done) return
      if (config.noLogin) {
        // NEVER Enforce this RULES !!!
        console.warn("[GATEWAY][UPNP][SECURITY] You can't MAPPING with noLogin feature!")
        return resolve(result)
      }
      if (loginWarn) {
        // NEVER Enforce this RULES !!!
        console.warn("[GATEWAY][UPNP][SECURITY] You can't MAPPING with default credentials!")
        return resolve(result)
      }
      // port Mapping
      console.log("[GATEWAY][UPNP] Mapping port: Internal", config.port, "-> External", config.portMapping)
      await client.map({
        description: "@bugsounet Gateway v2",
        protocol: 'tcp',
        public: config.portMapping,
        private: config.port,
        ttl: 0
      })
      result.done = true
      resolve(result)
    } catch (e) {
      console.log("[GATEWAY][UPNP] Return " + e)
      resolve(result)
    }
  })
}

async function portMappingDelete() {
  return new Promise(async resolve => {
    try {
      const client = await createUpnpClient()
      const currentMappings = await client.getMappings()
      if (currentMappings.length) {
        currentMappings.forEach(async mapping => {
          if(mapping.description == "@bugsounet Gateway v2") {
            console.warn("[GATEWAY][UPNP][SECURITY] Found Gateway upnp config:")
            await client.unmap({ public: mapping.public.port })
            console.warn("[GATEWAY][UPNP][SECURITY] Unmapping: Internal", mapping.private.port, "-> External", mapping.public.port)
          }
        })
      }
      resolve()
    } catch (e) {
      console.log("[GATEWAY][UPNP] Return " + e)
      resolve()
    }
  })
}

/** exports functions for pretty using **/
exports.purposeIP = purposeIP
exports.readConfig = readConfig
exports.saveConfig = saveConfig
exports.configAddOrModify = configAddOrModify
exports.configDelete = configDelete
exports.searchConfigured = searchConfigured
exports.searchInstalled = searchInstalled
exports.loadBackupNames = loadBackupNames
exports.loadBackupFile = loadBackupFile
exports.configMerge = configMerge
exports.checkElectronOptions = checkElectronOptions
exports.doClose = doClose
exports.restartMM = restartMM
exports.searchGA = searchGA
exports.getGAConfig = getGAConfig
exports.setWebviewTag = setWebviewTag
exports.deleteBackup = deleteBackup
exports.makeSchemaTranslate = makeSchemaTranslate
exports.readAllMMLogs = readAllMMLogs
exports.portMapping = portMapping
exports.portMappingDelete = portMappingDelete
exports.readFreeteuseTV = readFreeteuseTV
exports.readRadioRecipe = readRadioRecipe
