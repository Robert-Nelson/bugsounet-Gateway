const path = require("path")
const fs = require("fs")
const util = require("util")
const si = require('systeminformation')

function readConfig() {
  var MMConfig = undefined
  let file = path.resolve(__dirname, "../../../config/config.js")
  if (fs.existsSync(file)) MMConfig = require(file)
  return MMConfig
}

function saveConfig(MMConfig) {
  return new Promise(resolve => {
    var log = (...args) => { /* do nothing */ }
    var backupHistorySize = 20
    var configPath = path.resolve(__dirname, "../../../config/config.js")
    var best = -1
    var bestTime = null
    for (var i = backupHistorySize - 1; i > 0; i--) {
      let backupPath = path.resolve(__dirname ,"../backup/config.js.backup" + i)
      try {
        var stats = fs.statSync(backupPath)
        if (best === -1 || stats.mtime < bestTime) {
          best = i
          bestTime = stats.mtime
        }
      } catch (e) {
        if (e.code === "ENOENT") {
          best = i
          bestTime = "0000-00-00T00:00:00Z"
        }
      }
    }

    if (best === -1) {
      resolve({error: "Error! Backing up config failed, not saving!" })
      return console.log("[GATEWAY] Error! Backing up config failed, not saving!")
    }
    let backupPath = path.resolve(__dirname, "../backup/config.js.backup" + best)
    var source = fs.createReadStream(configPath)
    var destination = fs.createWriteStream(backupPath)

    source.pipe(destination, { end: false })
    source.on("end", () => {
      var header = "/*** GENERATED BY @bugsounet Gateway ***/\n\nvar config = "
      var footer = "\n\n/*************** DO NOT EDIT THE LINE BELOW ***************/\nif (typeof module !== 'undefined') {module.exports = config;}\n"

      fs.writeFile(configPath, header + util.inspect(MMConfig, {
          showHidden: false,
          depth: null,
          maxArrayLength: null,
          compact: false
        }) + footer,
        (error) => {
          if (error) {
            resolve({error: "Error when writing file" })
            return console.error("[GATEWAY] error", error)
          }
          console.log("[GATEWAY] Gateway saved new configuration!")
          console.log("[GATEWAY] Backup saved in", backupPath)
          resolve({done: "ok" })
        }
      )
    })
    destination.on("error", (error) => {
      resolve({error: "Error when writing file" })
      console.log("[GATEWAY]", error)
    })
  })
}

function configAddOrModify(EXTConfig, MMConfig) {
  return new Promise(resolve => {
    modules = MMConfig.modules
    index = modules.map(e => { return e.module }).indexOf(EXTConfig.module)
    if (index > -1) modules[index] = EXTConfig
    else modules.push(EXTConfig)
    resolve(MMConfig)
  })
}

function configDelete(EXT, MMConfig) {
  return new Promise(resolve => {
    modules = MMConfig.modules
    index = modules.map(e => { return e.module }).indexOf(EXT)
    modules.splice(index, 1) // delete modules
    resolve(MMConfig)
  })
}

function getIP () {
  return new Promise((resolve) => {
    si.networkInterfaceDefault()
      .then(defaultInt=> {
        si.networkInterfaces().then(data => {
          var Interfaces= []
          var int =0
          data.forEach(interface => {
            var info = {}
            if (interface.type == "wireless") {
              info = {
                ip: interface.ip4 ? interface.ip4 : "unknow",
                default: (interface.iface == defaultInt) ? true: false
              }
            }
            if (interface.type == "wired") {
              info = {
                ip: interface.ip4 ? interface.ip4 : "unknow",
                default: (interface.iface == defaultInt) ? true: false
              }
            }
            if (interface.iface != "lo") Interfaces.push(info)
            if (int == data.length-1) resolve(Interfaces)
            else int +=1
          })
        })
      })
      .catch(error => {
        console.log(error)
        var info = {}
        info = {
          ip: "127.0.0.1",
          default: true
        }
        Interfaces.push(info)
        resolve(Interfaces)
      })
  })
}

/** search and purpose and ip address **/
async function purposeIP() {
  var IP = await getIP()
  var found = 0
  return new Promise(resolve => {
    IP.forEach(network => {
      if (network.default) {
        resolve(network.ip)
        found = 1
        return
      }
    })
    if (!found) resolve("127.0.0.1")
  })
}

exports.purposeIP = purposeIP
exports.readConfig = readConfig
exports.saveConfig = saveConfig
exports.configAddOrModify = configAddOrModify
exports.configDelete = configDelete
